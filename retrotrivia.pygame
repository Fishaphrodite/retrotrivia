#!/usr/bin/env python
# Simple Quiz Game Engine in PyGame
# for Batocera Retrotrivia
# lbrpdx - 2020
# https://github.com/lbrpdx/retrotrivia
# License: LGPL 3.0
import pygame
import pygame.freetype
import random
import questions
import gamelists
import videoplayer
import itertools
import os

#######################################
### Global parameters
WINDOW_SURFACE   = pygame.HWSURFACE|pygame.DOUBLEBUF
SYS_FONT         = './assets/Bison.ttf' 
FONT_SIZE        = 50
TEXT_COLOR       = 'black'
BOX_COLOR        = 'blue'
BOX_COLOR_ANSWER = 'green'
BOX_COLOR_WRONG  = 'red'
BOX_WIDTH        = 10
TIMER            = 20  # seconds to respond
NUMBER_Q         = 10  # number of questions to ask
TIMER_COLOR      = 'green'
TIMER_COLOR_END  = 'red'
GAMEMODES        = [ 'A', 'V', 'T' ] # [V]ideos, [T]rivia, [A]ll
SOUND_VOL        = 0.7

#######################################
### List and types of questions
class QuestionBank:
    triviabank = None
    videobank  = None
    gamemode   = GAMEMODES[0]
    loaded     = 0  # number of questions loaded
    number_q   = NUMBER_Q
    timer      = TIMER

    def __init__(self):
        pass

    def load_all(self):
        self.triviabank = questions.Q[:]
        self.loaded += len (self.triviabank)
        gl = gamelists.gamelist()
        self.videobank = gl.load_all()[:]
        self.loaded += len (self.videobank)

#######################################
### Current Game state
class GameState:
    QB = None
    def __init__(self, nplayers, QB):
        self.current_question = None
        self.players     = 1    # FIXME
        self.QB          = QB
        self.questionst  = {}   # trivia questions
        self.questionsv  = {}   # video thumbnails questions
        self.right       = 0
        self.wrong       = 0
        self.score       = [ 0, 0, 0, 0 ] # FIXME one for each player, currently only player 1
        self.numq        = 0     # what question are we at?
        self.numqansw    = 0     # what question have we answered?
        self.sound_right = pygame.mixer.Sound('assets/playerright.wav')
        self.sound_wrong = pygame.mixer.Sound('assets/playeranswered.wav')
        self.sound_right.set_volume(SOUND_VOL)
        self.sound_wrong.set_volume(SOUND_VOL)

    def pop_question(self):
        if self.QB.gamemode == 'V' or self.QB.gamemode == 'A':
            if len (self.questionsv) < (self.QB.number_q - self.numqansw):
                self.questionsv = self.QB.videobank[:]
        if self.QB.gamemode == 'T' or self.QB.gamemode == 'A':
            if len (self.questionst) < (self.QB.number_q - self.numqansw):
                self.questionst = self.QB.triviabank[:]
        if self.QB.gamemode == 'A':
            if self.numq %2 == 0:
                try:
                    q = random.choice(self.questionsv)
                    self.questionsv.remove(q)
                except:
                    q = random.choice(self.questionst)
                    self.questionst.remove(q)
            else:
                q = random.choice(self.questionst)
                self.questionst.remove(q)
        elif self.QB.gamemode == 'V':
            try:
                q = random.choice(self.questionsv)
                self.questionsv.remove(q)
            except:
                q = random.choice(self.questionst)
                self.questionst.remove(q)
        else:
            q = random.choice(self.questionst)
            self.questionst.remove(q)
        self.numq += 1
        self.current_question = q
        return q

    def answer(self, answer, timer):
        if self.numqansw < self.numq:
            self.numqansw += 1
            if answer == self.current_question[1]:
                self.right += 1
                # FIXME: Only 1 player hardcoded
                self.score[1] += timer
                self.sound_right.play()
            else:
                self.wrong += 1
                # FIXME: Only 1 player hardcoded
                self.score[1] -= timer
                self.sound_wrong.play()
                if self.score[1] < 0:
                    self.score[1] = 0 # No negative score, too depressing

    def get_result(self):
        if self.score[1] > self.QB.number_q * self.QB.timer/2:
            tagline="GREAT SCORE!\n"
        elif self.score[1] > self.QB.number_q:
            tagline="NOT TOO BAD.\n"
        elif self.score[1] > self.QB.number_q/2:
            tagline="YOU CAN DO BETTER NEXT TIME.\n"
        else:
            tagline="OK, WE WON'T JUDGE YOU...\n"
        right = '\n{} answers were correct\n'.format(self.right) if self.right>1 \
            else '\nhuh, {} answer was correct\n'.format(self.right)
        wrong = '{} answers were wrong'.format(self.wrong) if self.wrong>1 \
            else'and, wow, {} answer was wrong'.format(self.wrong)
        return 'FINAL SCORE: {}\n'.format(self.score[1])+tagline+right+wrong



#######################################
### Simple static Screen
class StaticScreen:
    pygame.font.init()
    FONT = None
    QB = None
    def printline_center(self, text, x=0, y=0):
        xoffset = int(x+self.screen.get_width()/20)
        y = int(y+self.screen.get_height()/3)
        if self.FONT == None:
            self.FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*self.screen.get_height() / 1080))
        text = text.split('\n')
        for line in text:
            self.FONT.render_to(self.background, (xoffset, y), line.upper(), pygame.Color(TEXT_COLOR))
            y += int(FONT_SIZE*1.2*self.screen.get_height() / 1080)

    def __init__(self, next_scene, img, text):
        infoObject = pygame.display.Info()
        self.screen = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
        self.background = pygame.Surface((self.screen.get_width(), self.screen.get_height()))
        self.FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*self.screen.get_height() / 1080))
        self.img = img if img else None
        self.additional_text = text if text else None
        self.next_scene = next_scene

    def start(self, text):
        self.back_img = pygame.image.load('assets/back_cover.jpg')
        self.back_img = pygame.transform.scale(self.back_img, (self.screen.get_width(), self.screen.get_height()))
        self.background.blit(self.back_img, (0, 0))
        if self.img:
            self.foreground = pygame.image.load(self.img)
            img_ratio = self.foreground.get_width()/self.foreground.get_height()
            self.foreground = pygame.transform.scale(self.foreground, (int(self.screen.get_width()/4),
                        int(self.screen.get_width()/4/img_ratio)))
            self.background.blit(self.foreground, (int(self.screen.get_width()*0.375), int(self.screen.get_height()/5)))
        if text:
            if self.additional_text == None:
                self.additional_text = text
            else:
                self.additional_text += text
        self.draw(self.screen)

    def draw(self, screen):
        screen.blit(self.background, (0, 0))
        if self.additional_text:
            self.printline_center(self.additional_text,self.screen.get_width()/3, self.screen.get_height()/20)
            self.additional_text = None

    def update(self, events, dt):
        for event in events:
            if event.type == pygame.KEYDOWN:
                if event.key in (97, 98):  # 97 = [A], 98 =[B]
                    return (self.next_scene, None)

    def initialize_QB(self):
        if self.QB == None:
            self.QB = QuestionBank()
            self.QB.load_all()


#######################################
### Settings
class SettingsScreen:
    QB = None
    def __init__(self, QB):
        self.QB = QB
        infoObject = pygame.display.Info()
        self.screen = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
        self.background= pygame.Surface((self.screen.get_width(), self.screen.get_height()))
        self.back_img = pygame.image.load('assets/back_cover.jpg')
        self.back_img = pygame.transform.scale(self.back_img, (self.screen.get_width(), self.screen.get_height()))
        self.background.blit(self.back_img, (0, 0))
        if StaticScreen.FONT == None:
            StaticScreen.FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*self.screen.get_height() / 1080))
        StaticScreen.FONT.render_to(self.background, (int(self.screen.get_width()*3/8), int(self.screen.get_height()/10)), 'SETTINGS', pygame.Color(TEXT_COLOR))
        StaticScreen.FONT.render_to(self.background, (int(self.screen.get_width()*3/8), int(9*self.screen.get_height()/10)), '[HOTKEY]+[START] to quit', pygame.Color(TEXT_COLOR))
        self.rects_set, self.rects_down, self.rects_val, self.rects_up = [], [], [], []
        x = 10 + self.screen.get_width()/20
        y = self.screen.get_height()/4
        self.square = int(self.screen.get_height()/10)
        self.settings = [ 'NUMBER OF QUESTIONS:', 'TIME LIMIT:', '[V]IDEOS [T]RIVIA [A]LL' ]
        self.settings_val = [ NUMBER_Q, TIMER , GAMEMODES[0] ]
        self.it=itertools.cycle(GAMEMODES)
        next(self.it)
        for n in range(len(self.settings)):
            rect_set   = pygame.Rect(int(x+self.square*1.1), y+int(self.square/3), int(self.screen.get_width()/3+self.square), self.square)
            rect_down  = pygame.Rect(int(x+self.screen.get_width()/3+self.square*1.1), y, self.square, self.square)
            rect_val   = pygame.Rect(int(x+self.screen.get_width()/3+self.square*2.7), y+int(self.square/3), self.square, self.square)
            rect_up    = pygame.Rect(int(x+self.screen.get_width()/3+self.square*3.4), y, self.square, self.square)
            self.rects_set.append(rect_set)
            self.rects_down.append(rect_down)
            self.rects_val.append(rect_val)
            self.rects_up.append(rect_up)
            y += int(self.square*1.1)
        # default and start button
        # ysel = 3rd row
        self.rects_defaults   = pygame.Rect(int(x+self.screen.get_width()/3+self.square*0.1), y, self.square*2, self.square)
        self.rects_start      = pygame.Rect(int(x+self.screen.get_width()/3+self.square*3.4), y, self.square*2, self.square)
        self.xsel, self.ysel = 1, 3
        self.up_down = [ ]
        self.up_img = pygame.image.load('assets/chevron_up.png')
        self.up_img = pygame.transform.scale(self.up_img, (self.square, self.square))
        self.up_down.append(self.up_img)
        self.up_img = pygame.transform.rotate(self.up_img,180)
        self.up_down.append(self.up_img)

    def start(self, *args):
        pass

    def draw(self, screen):
        screen.blit(self.background, (0, 0))
        n = 0
        for rect in self.rects_val:
            StaticScreen.FONT.render_to(screen, self.rects_set[n], self.settings[n], pygame.Color(TEXT_COLOR))
            color = BOX_COLOR_ANSWER if (n == self.ysel and self.xsel == 0) else BOX_COLOR
            pygame.draw.rect(screen, pygame.Color(color), self.rects_down[n], int(BOX_WIDTH*self.screen.get_height() / 1080))
            screen.blit(self.up_down[1], (self.rects_down[n].x,self.rects_down[n].y))
            StaticScreen.FONT.render_to(screen, self.rects_val[n], str(self.settings_val[n]), pygame.Color(TEXT_COLOR))
            screen.blit(self.up_down[0], (self.rects_up[n].x,self.rects_up[n].y))
            color = BOX_COLOR_ANSWER if (n == self.ysel and self.xsel == 1) else BOX_COLOR
            pygame.draw.rect(screen, pygame.Color(color), self.rects_up[n], int(BOX_WIDTH*self.screen.get_height() / 1080))
            n += 1
        # default and start
        color = BOX_COLOR_ANSWER if (3 == self.ysel and self.xsel == 0) else BOX_COLOR
        pygame.draw.rect(screen, pygame.Color(color), self.rects_defaults, int(BOX_WIDTH*self.screen.get_height() / 1080))
        StaticScreen.FONT.render_to(screen, (self.rects_defaults.x+self.square/4,self.rects_defaults.y+self.square/2.5), 'DEFAULTS', pygame.Color(TEXT_COLOR))
        color = BOX_COLOR_ANSWER if (3 == self.ysel and self.xsel == 1) else BOX_COLOR
        pygame.draw.rect(screen, pygame.Color(color), self.rects_start, int(BOX_WIDTH*self.screen.get_height() / 1080))
        StaticScreen.FONT.render_to(screen, (self.rects_start.x+self.square/2.5,self.rects_start.y+self.square/2.5), 'START', pygame.Color(TEXT_COLOR))

    def action(self):
        if self.ysel == 0:
            # Number of questions
            if self.xsel == 0:
                self.settings_val[0] -= 1
                if self.settings_val[0] < 5:
                    self.settings_val[0] = 5
            elif self.xsel == 1:
                self.settings_val[0] += 1
                if self.settings_val[0] > 50:
                    self.settings_val[0] = 50
        elif self.ysel == 1:
            # Time limit
            if self.xsel == 0:
                self.settings_val[1] -= 1
                if self.settings_val[1] < 5:
                    self.settings_val[1] = 5
            elif self.xsel == 1:
                self.settings_val[1] += 1
                if self.settings_val[1] > 30:
                    self.settings_val[1] = 30
        elif self.ysel == 2:
            # Game mode
            if self.xsel == 0:
                for i in range(len(GAMEMODES)-1):
                    self.settings_val[2] = next(self.it)
            elif self.xsel == 1:
                self.settings_val[2] = next(self.it)
        elif self.ysel == 3:
            # Default and Start
            if self.xsel == 0:
                self.settings_val = [ NUMBER_Q, TIMER, GAMEMODES[0] ]
            elif self.xsel == 1:
                self.QB.number_q = self.settings_val[0]
                self.QB.timer    = self.settings_val[1]
                self.QB.gamemode = self.settings_val[2]
                return ('QUIZ', GameState(1, self.QB))
                #FIXME only 1 player hardcoded at the moment


    def update(self, events, dt):
        for event in events:
            if event.type == pygame.KEYDOWN:
                if event.key in (pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT, pygame.K_RIGHT, 97, 98):  # 97 = [A], 98 =[B]
                    if event.key == pygame.K_UP:
                        self.ysel = (self.ysel-1) % (len(self.settings)+1)
                    elif event.key == pygame.K_LEFT:
                        self.xsel = (self.xsel-1) % 2
                    elif event.key == pygame.K_RIGHT:
                        self.xsel = (self.xsel+1) % 2
                    elif event.key == pygame.K_DOWN:
                        self.ysel = (self.ysel+1) % (len(self.settings)+1)
                    elif event.key in (97, 98):
                        return self.action()


######################################
### Quizz Game Scene
class QuizScreen:
    def printline(self, text, x=0, y=0):
        xoffset = x
        y = y + self.screen.get_height()/20
        if StaticScreen.FONT == None:
            StaticScreen.FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*self.screen.get_height() / 1080))
        text = text.split('\n')
        for line in text:
            StaticScreen.FONT.render_to(self.background, (xoffset, y), line.upper(), pygame.Color(TEXT_COLOR))
            y += int(FONT_SIZE*1.2*self.screen.get_height() / 1080)

    def __init__(self):
        infoObject = pygame.display.Info()
        self.screen = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
        self.background= pygame.Surface((self.screen.get_width(), self.screen.get_height()))
        self.back_img = pygame.image.load('assets/back_q.jpg')
        self.back_img = pygame.transform.scale(self.back_img, (self.screen.get_width(), self.screen.get_height()))
        self.background.blit(self.back_img, (0, 0))
        self.vidsurface = None
        self.vsprite = None
        self.vsprite_group = None
        self.rects = []
        self.resps = []
        self.square = int(self.screen.get_height()/10)
        x = int(10 + self.screen.get_width()/20)
        y = int(self.screen.get_height()/2 + self.square)
        self.arrows = [ ]
        self.arrow_img = pygame.image.load('assets/arrow.png')
        self.arrow_img = pygame.transform.scale(self.arrow_img, (self.square, self.square))
        self.arrows.append(self.arrow_img)
        for i in range (3):
            self.arrow_img = pygame.transform.rotate(self.arrow_img,90)
            self.arrows.append(self.arrow_img)
        ricox = [ int(x + self.screen.get_width()*0.8 /2 /2),
                      int(x),
                      int(x + self.screen.get_width()*0.8 /2 /2),
                      int(x + self.screen.get_width()*0.8 /2) ]
        ricoy = [ int(y),
                      int(y + int(self.square*1.1)),
                      int(y + 2*int(self.square*1.1)),
                      int(y + int(self.square*1.1)) ]
        for n in range(4):
            rect = pygame.Rect(ricox[n], ricoy[n], self.square, self.square)
            resp = pygame.Rect(int(ricox[n]+self.square*1.1), ricoy[n], int(self.screen.get_width()*0.8/2-self.square*1.1), self.square)
            self.rects.append(rect)
            self.resps.append(resp)

    def start(self, gamestate):
        self.background.blit(self.back_img, (0, 0))
        self.gamestate = gamestate
        self.r = []
        for n in range(5):
            self.r.append('')
        self.question, self.answer, self.r[1], self.r[2], self.r[3], self.r[4] = gamestate.pop_question()
        # Clean and draw question
        if self.vsprite_group is not None:
            if self.vsprite is not None:
                self.vsprite_group.remove(self.vsprite)
                self.vsprite = None
            self.vsprite_goup = None
        if (self.question[-4:].rstrip()) == '.mp4':
            # Surface video player
            self.vidsurface = pygame.Rect(int(self.square*2.2), int(self.square/5),\
                int((self.screen.get_height()/2.1)*(4/3)), int(self.screen.get_height()/2+self.square*3/5))
            self.vsprite = videoplayer.VideoSprite(self.vidsurface, self.question)
            self.vsprite_group = pygame.sprite.Group()
            self.vsprite_group.add(self.vsprite)
        else:
            self.printline('\n'+self.question, 2*self.square, 0)
            self.vsprite = None
            self.vsprite_goup = None
        self.timer_started = True
        self.start_time = pygame.time.get_ticks() + gamestate.QB.timer * 1000 + 900 # margin to draw screen
        self.passed_time = self.start_time
        self.reveal = False
        self.vinput=0

    def draw(self, screen):
        screen.blit(self.background, (0, 0))
        n = 1
        for rect in self.rects:
            # Color boxes
            col      = BOX_COLOR
            wid      = BOX_WIDTH
            if self.reveal:
                if n == self.vinput:
                    col = BOX_COLOR_WRONG
                    wid *= 1.2
                if n == self.answer:
                    col = BOX_COLOR_ANSWER
                    wid *= 1.2
            pygame.draw.rect(screen, pygame.Color(col), rect, int(wid*self.screen.get_height() / 1080))
            self.background.blit(self.arrows[n-1], (rect.x, rect.y))
            self.printline(self.r[n], self.resps[n-1].x+self.square/3, self.resps[n-1].y)
            n += 1

        scorefont = pygame.font.Font(SYS_FONT, int(FONT_SIZE*self.screen.get_height() / 1080))
        scoretext = scorefont.render(' SCORE: {}'.format(self.gamestate.score[1]), True, TEXT_COLOR)
        self.screen.blit(scoretext, (int(self.screen.get_width()* 0.8), int(self.screen.get_height()* 0.4)))
        turntext = scorefont.render(' QUESTION: {}/{}'.format(self.gamestate.numq,self.gamestate.QB.number_q), True, TEXT_COLOR)
        self.screen.blit(turntext, (int(self.screen.get_width()* 0.8), int(self.screen.get_height()* 0.05)))
        if self.timer_started:
            # Larger font for the timer
            font = pygame.font.Font(SYS_FONT, 5 * int(FONT_SIZE*self.screen.get_height() / 1080))
            font_color = pygame.Color(TIMER_COLOR_END) if (self.passed_time/1000) <= 5 else pygame.Color(TIMER_COLOR)
            text = font.render(str(int(self.passed_time/1000)), True, font_color)
            self.screen.blit(text, (int(self.screen.get_width()* 0.8), int(self.screen.get_height()* 0.1)))
        if self.vsprite_group is not None:
             self.vsprite_group.update()
             self.vsprite_group.draw(self.screen)

    def update(self, events, dt):
        for event in events:
            if event.type == pygame.KEYDOWN:
                if self.gamestate.numqansw >= self.gamestate.numq:
                    break
                if self.reveal == False and \
                    event.key in (pygame.K_UP, pygame.K_DOWN, pygame.K_LEFT, pygame.K_RIGHT):
                    if event.key == pygame.K_UP:
                        self.vinput = 1
                    elif event.key == pygame.K_LEFT:
                        self.vinput = 2
                    elif event.key == pygame.K_DOWN:
                        self.vinput = 3
                    elif event.key == pygame.K_RIGHT:
                        self.vinput = 4
                    self.gamestate.answer(self.vinput, int(self.passed_time/1000))
                    self.reveal = True
        if self.reveal == False :
            self.passed_time = self.start_time - pygame.time.get_ticks()
            if (self.passed_time <= 0):
                self.passed_time = 0
                self.reveal = True
                self.vinput = 0
        else:
            return (self.reveal_res(events, dt))

    def reveal_res(self, events, dt):
        if self.vsprite_group is not None:
            if self.vsprite is not None:
                if self.vsprite.video_stop is False:
                    self.vsprite.stop()
        self.printline('PRESS [A]\nTO CONTINUE', int(self.screen.get_width()* 0.8), int(self.screen.get_height()*0.5))
        for event in events:
            if event.type == pygame.KEYDOWN:
                if event.key in (97, 98):  # Buttons A and B on joypad
                    if self.gamestate.numq < self.gamestate.QB.number_q:
                        return ('QUIZ', self.gamestate)
                    else:
                        score = self.gamestate.get_result()
                        del self.gamestate # Reset for next game
                        return ('RESULT', score)

#######################################
### Main Loop
def main():
    os.environ['SDL_AUDIODRIVER'] = 'alsa'
    pygame.mixer.pre_init(frequency=44100)
    pygame.init()
    pygame.mixer.init(frequency=44100)
    pygame.mouse.set_visible(0)
    infoObject = pygame.display.Info()
    screen = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
    clock = pygame.time.Clock()
    dt = 0
    scenes =  {'TITLE'   : StaticScreen('SETTINGS', 'assets/logo.png', '\nLOADING... PLEASE WAIT'),}
    scene = scenes['TITLE']
    scene.start(None)
    scene.draw(screen)
    pygame.display.flip()
    scene.initialize_QB()
    scene.start("\n{} QUESTIONS LOADED\nPress [A] to start\n[Hotkey]+[start] to quit".format(scene.QB.loaded))
    scenes.update({
        'SETTINGS': SettingsScreen(scene.QB),
        'QUIZ'    : QuizScreen(),
        'RESULT'  : StaticScreen('TITLE', '', ''),
    })
    while True:
        events = pygame.event.get()
        for e in events:
            if e.type == pygame.QUIT:
                return
        result = scene.update(events, dt)
        if result:
            next_scene, state = result
            if next_scene:
                scene = scenes[next_scene]
                scene.start(state)
        scene.draw(screen)
        pygame.display.flip()
        dt = clock.tick(60)

if __name__ == '__main__':
    main()
