#!/usr/bin/env python
# Simple Quiz Game Engine in PyGame
# for Batocera Retrotrivia
# lbrpdx - 2020
# https://github.com/lbrpdx/retrotrivia
# License: LGPL 3.0
import pygame
import pygame.freetype
import random
import questions
import gamelists
import videoplayer
import os
import sys
import psutil
import logging

#######################################
### Global parameters
DEBUG            = 1
WINDOW_SURFACE   = pygame.HWSURFACE|pygame.DOUBLEBUF
SYS_FONT         = './assets/Bison.ttf' 
FONT             = None
FONT_SIZE        = 50
TEXT_COLOR       = 'black'
TEXT_HALO        = 'white'
BOX_COLOR        = 'blue'
BOX_COLOR_ANSWER = 'green'
BOX_COLOR_WRONG  = 'red'
BOX_WIDTH        = 4
TIMER            = 30  # seconds to respond
NUMBER_Q         = 10  # number of questions to ask
TIMER_COLOR      = 'green'
TIMER_COLOR_END  = 'red'
GAMEMODES_NAMES  = [ 'Video', 'Trivia', 'Pixelate' ]
GAMEMODES        = [ 1, 1, 1 ]
SOUND_VOL        = 5
SCREEN           = None
JOYSTICKS        = [ None, None, None, None ]
LOGGER           = None
AUDIO_FREQ       = 44100
AUDIO_BUFFER     = 4096

#######################################
###  wrap/render text on a surface
class DrawText:
    def __init__(self, surface, text, color, rect, yoffset=0, lineSpacing=1):
        opx = 3
        text = text.upper().split('\n')
        rendtext = FONT.render("TgM") # Sample text to render
        fontHeight = int(rendtext[1][3])
        y = rect.top + fontHeight * yoffset
        for line in text:
            while line:
                i = 1
                # determine if the row of text will be outside our Rect area
                if y + fontHeight > rect.bottom:
                    break
                # determine maximum width of line
                while (FONT.render(line[:i])[1][2] < rect.width) and (i < len(line)):
                    i += 1
                # if we wrap the line, then adjust to the last word
                if i < len(line):
                    i = line.rfind(" ", 0, i) + 1
                # render the line and blit it to the surface
                image = FONT.render(line[:i], color)
                surface.blit(image[0], (rect.left, y))
                y += int(fontHeight *(1 + 0.2* lineSpacing))
                # remove the text we just blitted
                line = line[i:]
        return # line contains remaining text

#########################################
## Manage sound from multiple objects (otherwise : crash)
class SoundManager:
    def __init__(self):
        self.sound = None
        self.vol = 0
        pygame.mixer.init(frequency=AUDIO_FREQ, buffer=AUDIO_BUFFER)

    def volume(self, new_vol):
        self.vol = new_vol

    def play(self, sound_file):
        if pygame.mixer.get_busy():
            pygame.mixer.stop()
        if not os.path.isfile(sound_file):
            return
        self.sound = pygame.mixer.Sound(sound_file)
        if self.vol > 0:
            self.sound.set_volume(0.2*self.vol)
            self.sound.play()

#########################################
## Check if a process is running (pad2key conflicts with joypad)
def is_ps_running (pname):
    for proc in psutil.process_iter():
        try:
            # Check if process name contains the given name string.
            if pname.lower() in proc.name().lower():
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return False;

#########################################
## log messages to stdout
def log(message):
    global LOGGER
    if DEBUG > 0:
        LOGGER.debug(message)

#########################################
## Joystick/pad/keyboard events
def key_pressed (event, joypad):
    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_UP:
            return 'up'
        elif event.key == pygame.K_LEFT:
            return 'left'
        elif event.key == pygame.K_RIGHT:
            return 'right'
        elif event.key == pygame.K_DOWN:
            return 'down'
        elif event.key in (97, 98):  # A and B keys
            return 'action'
    elif joypad != None and event.type == pygame.JOYAXISMOTION:  # Analogue Hat
        if joypad.get_axis(1) <= -1:
            return 'up'
        elif joypad.get_axis(0) <= -1:
            return 'left'
        elif joypad.get_axis(0) >= 0.5:
            return 'right'
        elif joypad.get_axis(1) >= 0.5:
            return 'down'
    elif joypad != None and event.type == pygame.JOYBUTTONDOWN:
        if (DEBUG):
            for k in range (joypad.get_numbuttons()):
                if joypad.get_button(k):
                    log ("Joypad event: {}".format(k))
        if joypad.get_button(8):
            return 'up'
        elif joypad.get_button(10):
            return 'left'
        elif joypad.get_button(11):
            return 'right'
        elif joypad.get_button(9):
            return 'down'
        if joypad.get_button(0) or joypad.get_button(1):  # Buttons A or B
            return 'action'

#######################################
### List and types of questions
class QuestionBank:
    triviabank     = None
    videobank      = None
    loaded_systems = None
    loaded         = 0          # number of questions loaded
    gamemode       = GAMEMODES  # Also save settings here
    timer          = TIMER
    number_q       = NUMBER_Q
    sound_vol      = SOUND_VOL

    def __init__(self):
        pass

    def load_all(self):
        self.triviabank = questions.Q[:]
        self.loaded += len (self.triviabank)
        gl = gamelists.gamelist()
        self.videobank = gl.load_all()[:]
        self.loaded += len (self.videobank)
        self.loaded_systems = gl.loaded_systems[:]

#######################################
### Current Game state
class GameState:
    QB = None

    def __init__(self, nplayers, QB):
        self.current_question = None
        self.current_mode     = 0
        self.players          = 1    # FIXME
        self.QB               = QB
        self.questionst       = {}   # trivia questions
        self.questionsv       = {}   # video thumbnails questions
        self.right            = 0
        self.wrong            = 0
        self.score            = [ 0, 0, 0, 0 ] # FIXME one for each player, currently only player 1
        self.numq             = 0     # what question are we at?
        self.numqansw         = 0     # what question have we answered?

    def pop_question(self):
        log ("GameState pop question")
        if len (self.questionst) < (self.QB.number_q - self.numqansw):
            self.questionst = self.QB.triviabank[:]
        # Remind: GAMEMODES_NAMES  = [ 'Video', 'Trivia', 'Pixelate' ]
        if self.QB.gamemode[0] == 1 or self.QB.gamemode[2] == 1 :
            if len (self.questionsv) < (self.QB.number_q - self.numqansw):
                self.questionsv = self.QB.videobank[:]
        ntry = 0
        self.current_mode = (self.current_mode+1) % len(GAMEMODES)
        while (ntry <= len(self.QB.gamemode) and self.QB.gamemode[self.current_mode] == 0):
            self.current_mode = (self.current_mode+1) % len(GAMEMODES)
            ntry += 1
        if self.QB.gamemode[self.current_mode] == 0:
            self.current_mode = 1 # Force trivia (even if not selected, because nothing else)
        self.numq += 1
        log("Question {} mode {}: ({})".format(str(self.numq), str(self.current_mode), GAMEMODES_NAMES[self.current_mode]))
        # Video (normal or pixelated)
        if self.current_mode == 0 or self.current_mode == 2:
                try:
                    q = random.choice(self.questionsv)
                    self.questionsv.remove(q)
                except:
                    q = random.choice(self.questionst)
                    self.questionst.remove(q)
        else:
            q = random.choice(self.questionst)
            self.questionst.remove(q)
        self.current_question = q
        log("Question: {}".format(str(q)))
        return q

    def get_answer(self, answer, timer):
        if self.numqansw < self.numq:
            self.numqansw += 1
            if answer == self.current_question[1]:
                self.right += 1
                # FIXME: Only 1 player hardcoded
                self.score[1] += timer
                log ("Question {} was right at {} sec".format(self.numqansw, timer))
                return True
            else:
                self.wrong += 1
                # FIXME: Only 1 player hardcoded
                self.score[1] -= timer
                if self.score[1] < 0:
                    self.score[1] = 0 # No negative score, too depressing
                log ("Question {} was wrong at {} sec".format(self.numqansw, timer))
                return False

    def get_result(self):
        log ("Game Over")
        if self.score[1] > self.QB.number_q * self.QB.timer/2:
            tagline="GREAT SCORE!\n"
        elif self.score[1] > self.QB.number_q:
            tagline="NOT TOO BAD.\n"
        elif self.score[1] > self.QB.number_q/2:
            tagline="YOU CAN DO BETTER NEXT TIME.\n"
        else:
            tagline="OK, WE WON'T JUDGE YOU...\n"
        tright = '\n{} answers were correct\n'.format(self.right) if self.right>1 \
            else '\nhuh, {} answer was correct\n'.format(self.right)
        twrong = '{} answers were wrong'.format(self.wrong) if self.wrong>1 \
            else 'and, wow, {} answer was wrong'.format(self.wrong)
        return 'FINAL SCORE: {}\n'.format(self.score[1])+tagline+tright+twrong


#######################################
### Simple static Screen
class StaticScreen:
    QB = None

    def __init__(self, next_scene, img, text):
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.img = img if img else None
        self.additional_text = text if text else None
        self.next_scene = next_scene

    def start(self, text):
        self.back_img = pygame.image.load('assets/back_cover.jpg')
        self.back_img = pygame.transform.scale(self.back_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.background.blit(self.back_img, (0, 0))
        if self.img:
            self.foreground = pygame.image.load(self.img)
            img_ratio = self.foreground.get_width()/self.foreground.get_height()
            self.foreground = pygame.transform.scale(self.foreground, (int(SCREEN.get_width()/4),
                        int(SCREEN.get_width()/4/img_ratio)))
            self.background.blit(self.foreground, (int(SCREEN.get_width()*0.375), int(SCREEN.get_height()/5)))
        if text:
            if self.additional_text == None:
                self.additional_text = text
            else:
                self.additional_text += text
        self.draw()

    def draw(self):
        SCREEN.blit(self.background, (0, 0))
        if self.additional_text:
            p_surface=pygame.Rect(SCREEN.get_width()*0.375, SCREEN.get_height()*0.375,\
                      SCREEN.get_width()/3, SCREEN.get_height()/2)
            DrawText(self.background, self.additional_text, TEXT_COLOR, p_surface, 3, 2)
            self.additional_text = None

    def update(self, events, dt):
        for event in events:
            if key_pressed (event, JOYSTICKS[0]) == 'action':
                return (self.next_scene, None)

    def initialize_QB(self):
        if self.QB == None:
            self.QB = QuestionBank()
            self.QB.load_all()


#######################################
### Settings
class SettingsScreen:
    QB = None

    def __init__(self, QB):
        self.QB = QB
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.rects_set, self.rects_down, self.rects_val, self.rects_up = [], [], [], []
        x = 10 + SCREEN.get_width()/20
        y = SCREEN.get_height()/5
        self.square = int(SCREEN.get_height()/10)
        self.settings = [ 'NUMBER OF QUESTIONS:', 'TIME LIMIT:', 'SOUND VOLUME', 'GAME MODES:' ]
        self.settings_val = [ NUMBER_Q, TIMER, SOUND_VOL, GAMEMODES[:] ]
        for n in range(3):
            rect_set   = pygame.Rect(int(x+self.square), y, int(SCREEN.get_width()/4+self.square), self.square)
            rect_down  = pygame.Rect(int(x+SCREEN.get_width()/4+self.square), y, self.square, self.square)
            rect_val   = pygame.Rect(int(x+SCREEN.get_width()/4+self.square*2.5), y, self.square, self.square)
            rect_up    = pygame.Rect(int(x+SCREEN.get_width()/4+self.square*3.5), y, self.square, self.square)
            self.rects_set.append(rect_set)
            self.rects_down.append(rect_down)
            self.rects_val.append(rect_val)
            self.rects_up.append(rect_up)
            y += int(self.square*1.1)
        # Gamemodes
        self.rects_gmodes = pygame.Rect(int(x+self.square*1.1), y, self.square*2, self.square)
        self.rects_gmode = []
        self.rects_gmval = []
        for i in range(len(GAMEMODES)):
            self.rects_gmval.append(pygame.Rect(int(x+SCREEN.get_width()/4+self.square*(1+2.5*i)), y, self.square, self.square))
            self.rects_gmode.append(pygame.Rect(int(x+SCREEN.get_width()/4+self.square*(2.2+2.5*i)), y, 2*self.square, self.square))
        y += int(self.square*1.1)
        # default and start button
        self.rects_defaults   = pygame.Rect(int(x+SCREEN.get_width()/4+self.square), y, self.square*2, self.square)
        self.rects_start      = pygame.Rect(int(x+SCREEN.get_width()/4+self.square*3.5), y, self.square*2, self.square)
        # ysel = 5rd row, 2nd button
        self.xsel, self.ysel = 1, 4
        self.up_down = [ ]
        self.up_img = pygame.image.load('assets/chevron_up.png')
        self.up_img = pygame.transform.scale(self.up_img, (self.square, self.square))
        self.up_down.append(self.up_img)
        self.up_img = pygame.transform.rotate(self.up_img,180)
        self.up_down.append(self.up_img)
        self.right_icon = pygame.image.load('assets/right.png')
        self.right_icon = pygame.transform.scale(self.right_icon, (self.square, self.square))
        self.wrong_icon = pygame.image.load('assets/wrong.png')
        self.wrong_icon = pygame.transform.scale(self.wrong_icon, (self.square, self.square))
        self.static_bkg_img = pygame.image.load('assets/back_cover.jpg')
        self.static_bkg_img = pygame.transform.scale(self.static_bkg_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.background.blit(self.static_bkg_img, (0, 0))
        pygame.display.flip()

    def start(self, *args):
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        self.background.blit(self.back_img, (0, 0))
        p_surface=pygame.Rect(SCREEN.get_width()*3/8, SCREEN.get_height()/12,\
                  SCREEN.get_width()/3, SCREEN.get_height()/10)
        DrawText(self.background, 'Settings', TEXT_COLOR, p_surface, 1, 1)
        p_surface2=pygame.Rect(SCREEN.get_width()*3/8, SCREEN.get_height()*8/10,\
                  SCREEN.get_width()/3, SCREEN.get_height()/10)
        DrawText(self.background, '[Hotkey]+[Start] to quit', TEXT_COLOR, p_surface2, 1, 1)
        n = 0
        for rect in self.rects_val:
            DrawText(self.background, self.settings[n], TEXT_COLOR, self.rects_set[n], 1, 1)
            n += 1
        DrawText(self.background, "Game modes:", TEXT_COLOR, self.rects_gmodes, 1, 1)
        for i in range(len(self.rects_gmode)):
            DrawText(self.background, GAMEMODES_NAMES[i], TEXT_COLOR, self.rects_gmode[i], 1, 1)
        pygame.display.flip()

    def draw(self):
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        n = 0
        for rect in self.rects_val:
            color = BOX_COLOR_ANSWER if (n == self.ysel and self.xsel == 0) else BOX_COLOR
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_down[n], int(BOX_WIDTH*SCREEN.get_height() / 1080))
            self.background.blit(self.up_down[1], (self.rects_down[n].x,self.rects_down[n].y))
            subsurface = self.static_bkg_img.subsurface(self.rects_val[n])
            self.background.blit(subsurface, (self.rects_val[n].x, self.rects_val[n].y))
            FONT.render_to(self.background, (self.rects_val[n].x+self.square/3,self.rects_val[n].y+self.square/3),\
                    str(self.settings_val[n]), pygame.Color(TEXT_COLOR))
            self.background.blit(self.up_down[0], (self.rects_up[n].x,self.rects_up[n].y))
            color = BOX_COLOR_ANSWER if (n == self.ysel and self.xsel == 1) else BOX_COLOR
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_up[n], int(BOX_WIDTH*SCREEN.get_height() / 1080))
            n += 1
        for i in range(len(self.rects_gmode)):
            color = BOX_COLOR_ANSWER if (3 == self.ysel and self.xsel == i) else BOX_COLOR
            ico = self.right_icon if self.settings_val[3][i] == 1 else self.wrong_icon
            subsurface = self.static_bkg_img.subsurface(self.rects_gmval[i])
            self.background.blit(subsurface, (self.rects_gmval[i].x, self.rects_gmval[i].y))
            self.background.blit(ico, (self.rects_gmval[i].x,self.rects_gmval[i].y))
            pygame.draw.rect(self.background, pygame.Color(color), self.rects_gmval[i], int(BOX_WIDTH*SCREEN.get_height() / 1080))
        # defaults and start
        color = BOX_COLOR_ANSWER if (4 == self.ysel and self.xsel == 0) else BOX_COLOR
        pygame.draw.rect(self.background, pygame.Color(color), self.rects_defaults, int(BOX_WIDTH*SCREEN.get_height() / 1080))
        FONT.render_to(self.background, (self.rects_defaults.x+self.square/4,self.rects_defaults.y+self.square/2.5), 'DEFAULTS', pygame.Color(TEXT_COLOR))
        color = BOX_COLOR_ANSWER if (4 == self.ysel and self.xsel == 1) else BOX_COLOR
        pygame.draw.rect(self.background, pygame.Color(color), self.rects_start, int(BOX_WIDTH*SCREEN.get_height() / 1080))
        FONT.render_to(self.background, (self.rects_start.x+self.square/2.5,self.rects_start.y+self.square/2.5), 'START', pygame.Color(TEXT_COLOR))

    def action(self):
        if self.ysel == 0:
            # Number of questions
            if self.xsel == 0:
                self.settings_val[0] -= 1
                if self.settings_val[0] < 5:
                    self.settings_val[0] = 5
            elif self.xsel == 1:
                self.settings_val[0] += 1
                if self.settings_val[0] > 50:
                    self.settings_val[0] = 50 # 50 questions max
        elif self.ysel == 1:
            # Time limit
            if self.xsel == 0:
                self.settings_val[1] -= 1
                if self.settings_val[1] < 5:
                    self.settings_val[1] = 5
            elif self.xsel == 1:
                self.settings_val[1] += 1
                if self.settings_val[1] > 60:
                    self.settings_val[1] = 60 # 60 sec max
        elif self.ysel == 2:
            # Sound volume
            if self.xsel == 0:
                self.settings_val[2] -= 1
                if self.settings_val[2] < 0:
                    self.settings_val[2] = 0
            elif self.xsel == 1:
                self.settings_val[2] += 1
                if self.settings_val[2] > SOUND_VOL:
                    self.settings_val[2] = SOUND_VOL
        elif self.ysel == 3:
            # Game mode
            if self.xsel == 0:
                self.settings_val[3][0] = (self.settings_val[3][0]+1)%2
            elif self.xsel == 1:
                self.settings_val[3][1] = (self.settings_val[3][1]+1)%2
            elif self.xsel == 2:
                self.settings_val[3][2] = (self.settings_val[3][2]+1)%2
        elif self.ysel == 4:
            # Default and Start
            if self.xsel == 0:
                self.settings_val = [ NUMBER_Q, TIMER, SOUND_VOL, GAMEMODES[:] ]
            elif self.xsel == 1:
                self.QB.number_q  = self.settings_val[0]
                self.QB.timer     = self.settings_val[1]
                self.QB.sound_vol = self.settings_val[2]
                self.QB.gamemode  = self.settings_val[3]
                log("Number of questions: {}, timer: {}, sound vol: {}".format(self.QB.number_q, self.QB.timer, self.QB.sound_vol))
                log("Selected gamemodes: {}".format(self.QB.gamemode))
                return ('QUIZ', GameState(1, self.QB))
                #FIXME only 1 player hardcoded at the moment

    def update(self, events, dt):
        for event in events:
            if key_pressed (event, JOYSTICKS[0]) == 'up':
                self.ysel = (self.ysel-1) % (len(self.settings)+1)
                if (self.ysel != 3) and (self.xsel > 1):
                    self.xsel = 1
            elif key_pressed (event, JOYSTICKS[0]) == 'left':
                if (self.ysel == 3):
                    self.xsel = (self.xsel-1) % 3
                else:
                    self.xsel = (self.xsel-1) % 2
            elif key_pressed (event, JOYSTICKS[0]) == 'right':
                if (self.ysel == 3):
                    self.xsel = (self.xsel+1) % 3
                else:
                    self.xsel = (self.xsel+1) % 2
            elif key_pressed (event, JOYSTICKS[0]) == 'down':
                self.ysel = (self.ysel+1) % (len(self.settings)+1)
                if (self.ysel != 3) and (self.xsel > 1):
                    self.xsel = 1
            elif key_pressed (event, JOYSTICKS[0]) == 'action':
                return self.action()

######################################
### Larger countdown
def circlepoints(r, ccache):
    r = int(round(r))
    if r in ccache:
        return ccache[r]
    x, y, e = r, 0, 1 - r
    ccache[r] = points = []
    while x >= y:
        points.append((x, y))
        y += 1
        if e < 0:
            e += 2 * y - 1
        else:
            x -= 1
            e += 2 * (y - x) - 1
    points += [(y, x) for x, y in points if x > y]
    points += [(-x, y) for x, y in points if x]
    points += [(x, -y) for x, y in points if y]
    points.sort()
    return points

class Timer(pygame.sprite.Sprite):
    circle_cache = {}

    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.image = None
        self.font = pygame.font.Font(SYS_FONT, 5 * int(FONT_SIZE*SCREEN.get_height() / 1080))

    def update (self, passed_time, max_timer, opx=5):
        # Larger font for the timer
        opx=opx*SCREEN.get_height()//1080
        font_color = pygame.Color(TIMER_COLOR_END) if passed_time <= 5 else pygame.Color(TIMER_COLOR)
        text = str(passed_time if passed_time < max_timer else max_timer)
        textsurface = self.font.render(text, True, font_color).convert_alpha()
        w = textsurface.get_width() + 2 * opx
        h = self.font.get_height()
        osurf = pygame.Surface((w, h + 2 * opx)).convert_alpha()
        osurf.fill((0, 0, 0, 0))
        surf = osurf.copy()
        osurf.blit(self.font.render(text, True, TEXT_HALO).convert_alpha(), (0, 0))
        for dx, dy in circlepoints(opx, self.circle_cache):
            surf.blit(osurf, (dx + opx, dy + opx))
        surf.blit(textsurface, (opx, opx))

        #self.image = self.font.render(str(passed_time if passed_time < max_timer else max_timer), True, font_color)
        self.image = surf
        self.rect = (int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.1))

######################################
### Quizz Game Scene
class QuizScreen:
    def __init__(self):
        self.square = int(SCREEN.get_height()/10)
        self.background = pygame.Surface((SCREEN.get_width(), SCREEN.get_height()))
        self.right_icon = pygame.image.load('assets/right.png')
        self.right_icon = pygame.transform.scale(self.right_icon, (self.square, self.square))
        self.wrong_icon = pygame.image.load('assets/wrong.png')
        self.wrong_icon = pygame.transform.scale(self.wrong_icon, (self.square, self.square))
        self.static_bkg_img = pygame.image.load('assets/back_q.jpg')
        self.static_bkg_img = pygame.transform.scale(self.static_bkg_img, (SCREEN.get_width(), SCREEN.get_height()))
        self.scorefont = pygame.font.Font(SYS_FONT, int(FONT_SIZE*SCREEN.get_height() / 1080))
        self.back_img = self.static_bkg_img.copy()
        self.background.blit(self.back_img, (0, 0))
        self.q_surface = None
        self.vsprite = None
        self.vsprite_group = None
        self.reveal = False
        self.rects = []
        self.resps = []
        x = int(10 + SCREEN.get_width()/20)
        y = int(SCREEN.get_height()/2 + self.square)
        self.arrows = [ ]
        self.arrow_img = pygame.image.load('assets/arrow.png')
        self.arrow_img = pygame.transform.scale(self.arrow_img, (self.square, self.square))
        self.arrows.append(self.arrow_img)
        for i in range (3):
            self.arrow_img = pygame.transform.rotate(self.arrow_img,90)
            self.arrows.append(self.arrow_img)
        ricox = [ int(x + SCREEN.get_width()*0.8 /2 /2),
                      int(x),
                      int(x + SCREEN.get_width()*0.8 /2 /2),
                      int(x + SCREEN.get_width()*0.8 /2) ]
        ricoy = [ int(y),
                      int(y + int(self.square*1.1)),
                      int(y + 2*int(self.square*1.1)),
                      int(y + int(self.square*1.1)) ]
        for n in range(4):
            rect = pygame.Rect(ricox[n], ricoy[n], self.square, self.square)
            resp = pygame.Rect(int(ricox[n]+self.square*1.2), int(ricoy[n]+self.square*0.2), int(SCREEN.get_width()*0.8/2-self.square*1.1), self.square)
            self.rects.append(rect)
            self.resps.append(resp)
        self.countdown = Timer()
        self.sound_manager = SoundManager()

    def start(self, gamestate):
        self.gamestate = gamestate
        self.sound_manager.volume(gamestate.QB.sound_vol)
        self.r = []
        for n in range(5):
            self.r.append('')
        self.question, self.answer, self.r[1], self.r[2], self.r[3], self.r[4] = gamestate.pop_question()
        # Clean and draw question
        if self.vsprite_group is not None:
            if self.vsprite is not None:
                self.vsprite_group.remove(self.vsprite)
                self.vsprite = None
            self.vsprite_goup = None
        self.q_surface = pygame.Rect(int(self.square*2.2), int(self.square/5),\
            int((SCREEN.get_height()/2.1+self.square*3/5)*(4/3)), int(SCREEN.get_height()/2.1+self.square*3/5))
        if (self.question[-4:].rstrip()) == '.mp4':
            # Surface video player
            pixelated = True if self.gamestate.current_mode == 2 else False
            self.vsprite = videoplayer.VideoSprite(self.q_surface, self.question, self.sound_manager, pixelated)
            self.vsprite_group = pygame.sprite.Group()
            self.vsprite_group.add(self.vsprite)
        else:
            self.vsprite = None
            self.vsprite_goup = None
        self.contsurf = pygame.Rect(int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.5),\
                                int(SCREEN.get_height()*0.2), int(SCREEN.get_height()*0.2))
        self.timer_started = True
        self.start_time = pygame.time.get_ticks() + gamestate.QB.timer * 1000 + 950 # margin to draw screen
        self.passed_time = self.start_time
        self.reveal = False
        self.vinput = 0
        self.back_img = self.static_bkg_img.copy()
        SCREEN.blit(self.background, (0, 0))
        if (self.question[-4:].rstrip()) != '.mp4':
            DrawText(self.back_img, self.question, TEXT_COLOR, self.q_surface, 3, 2)
        n = 1
        for rect in self.rects:
            DrawText(self.back_img, self.r[n], TEXT_COLOR, self.resps[n-1])
            n += 1
        pygame.display.flip()
        self.countdown_list = pygame.sprite.Group()
        self.countdown_list.add(self.countdown)

    def draw(self):
        self.background.blit(self.back_img, (0, 0))
        SCREEN.blit(self.background, (0, 0))
        n = 1
        for rect in self.rects:
            # Color boxes
            col      = BOX_COLOR
            wid      = BOX_WIDTH
            self.back_img.blit(self.arrows[n-1], (rect.x, rect.y))
            if self.reveal:
                if n == self.vinput:
                    col = BOX_COLOR_WRONG
                    pygame.draw.rect(self.back_img, pygame.Color(col), rect, 0) # 0 = fill
                    self.back_img.blit(self.wrong_icon, (rect.x, rect.y))
                if n == self.answer:
                    col = BOX_COLOR_ANSWER
                    pygame.draw.rect(self.back_img, pygame.Color(col), rect, 0) # 0 = fill
                    self.back_img.blit(self.right_icon, (rect.x, rect.y))
            n += 1

        subsurface = self.static_bkg_img.subsurface((int(SCREEN.get_width()*0.8),0,int(SCREEN.get_width()*0.2),SCREEN.get_height()//2))
        self.back_img.blit(subsurface, (int(SCREEN.get_width()*0.8), 0))
        score_col = TEXT_COLOR
        updown = ''
        if self.reveal:
            if self.vinput != 0:
                score_col = BOX_COLOR_ANSWER if self.vinput == self.answer else BOX_COLOR_WRONG
                updown = "up" if self.vinput == self.answer else "down"
            DrawText(self.back_img, 'Press [A] to continue', TEXT_COLOR, self.contsurf, 0, 2)
        scoretext = self.scorefont.render('SCORE {}: {}'.format(updown,self.gamestate.score[1]), True, score_col)
        self.back_img.blit(scoretext, (int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.4)))
        turntext = self.scorefont.render('QUESTION: {}/{}'.format(self.gamestate.numq,self.gamestate.QB.number_q), True, TEXT_COLOR)
        self.back_img.blit(turntext, (int(SCREEN.get_width()*0.8), int(SCREEN.get_height()*0.05)))
        self.countdown_list.update(int(self.passed_time/1000), self.gamestate.QB.timer)
        self.countdown_list.draw(self.back_img)

        if self.vsprite_group is not None:
             self.vsprite_group.update(int(self.passed_time/1000), self.gamestate.QB.timer)
             self.vsprite_group.draw(self.back_img)

        SCREEN.blit(self.background, (0, 0))

    def update(self, events, dt):
        if self.reveal == False :
            self.passed_time = self.start_time - pygame.time.get_ticks()
            for event in events:
                if self.gamestate.numqansw >= self.gamestate.numq:
                    break
                if self.reveal == False:
                    if key_pressed (event, JOYSTICKS[0]) == 'up':
                        self.vinput = 1
                    elif key_pressed (event, JOYSTICKS[0]) == 'left':
                        self.vinput = 2
                    elif key_pressed (event, JOYSTICKS[0]) == 'right':
                        self.vinput = 4
                    elif key_pressed (event, JOYSTICKS[0]) == 'down':
                        self.vinput = 3
                    if self.vinput != 0:
                        res = self.gamestate.get_answer(self.vinput,
                            int(self.passed_time/1000 if self.passed_time/1000 < self.gamestate.QB.timer
                            else self.gamestate.QB.timer))
                        if self.gamestate.QB.sound_vol > 0:
                            if res:
                                self.sound_manager.play('assets/playerright.wav')
                            else:
                                self.sound_manager.play('assets/playeranswered.wav')
                        self.reveal = True
                        log("Reveal answer")
            if (self.passed_time <= 0):
                self.passed_time = 0
                self.reveal = True
                log("Time's up")
                self.sound_manager.play('assets/timeout.wav')
                self.vinput = 0
        else:
            try:
                if self.vsprite_group is not None:
                    if self.vsprite is not None:
                        if self.vsprite.video_stop is False:
                            log ("Stop video sprite")
                            self.vsprite.stop()
            except:
                log ("Error while killing video sprite")
                pass
            for event in events:
                if key_pressed (event, JOYSTICKS[0]) == 'action':
                    log ("Next screen")
                    if self.gamestate.numq < self.gamestate.QB.number_q:
                        return ('QUIZ', self.gamestate)
                    else:
                        score = self.gamestate.get_result()
                        del self.gamestate # Reset for next game
                        return ('RESULT', score)
            return None

#######################################
### Main Loop
def main():
    global FONT
    global SCREEN
    global JOYSTICKS
    global LOGGER
    LOGGER = logging.getLogger()
    LOGGER.setLevel(logging.DEBUG)
    loghandler = logging.StreamHandler(sys.stderr)
    logformat = logging.Formatter('[%(asctime)s] %(message)s')
    loghandler.setFormatter(logformat)
    LOGGER.addHandler(loghandler)
    os.environ['SDL_AUDIODRIVER'] = 'alsa'
    pygame.mixer.pre_init(frequency=AUDIO_FREQ, buffer=AUDIO_BUFFER)
    pygame.init()
    pygame.mouse.set_visible(0)
    infoObject = pygame.display.Info()
    SCREEN = pygame.display.set_mode((infoObject.current_w, infoObject.current_h), WINDOW_SURFACE)
    log ("Game screen: {}x{}".format(SCREEN.get_width(), SCREEN.get_height()))
    pygame.font.init()
    if FONT == None:
        FONT = pygame.freetype.Font(SYS_FONT, int(FONT_SIZE*SCREEN.get_height() / 1080))
    pygame.joystick.init()
    njoy = pygame.joystick.get_count()
    log("Number of joysticks found: {}".format(njoy))
    pad2key = is_ps_running ('evmapy')
    for i in range(njoy):
        if i == 0 and pad2key:
            log("Pad2key found, ignoring joystick {}".format(i))
            break
        JOYSTICKS[i] = pygame.joystick.Joystick(i)
        JOYSTICKS[i].init()
        log("Joystick {} initialized".format(i))
    clock = pygame.time.Clock()
    dt = 0
    scenes =  {'TITLE'   : StaticScreen('SETTINGS', 'assets/logo.png', '\nLOADING... PLEASE WAIT'),}
    scene = scenes['TITLE']
    scene.start(None)
    starttime = pygame.time.get_ticks()
    scene.draw()
    pygame.display.flip()
    scene.initialize_QB()
    log("Loaded systems:")
    for n in scene.QB.loaded_systems:
        log (n)
    delta = (pygame.time.get_ticks() - starttime) // 1000
    scene.start("\n\n{} QUESTIONS LOADED IN {} SEC\nPress [A] to start\n[Hotkey]+[start] to quit".format(scene.QB.loaded, delta))
    scenes.update({
        'SETTINGS': SettingsScreen(scene.QB),
        'QUIZ'    : QuizScreen(),
        'RESULT'  : StaticScreen('TITLE', '', ''),
    })
    while True:
        events = pygame.event.get()
        for e in events:
            if e.type == pygame.QUIT:
                return
            if JOYSTICKS[0] and JOYSTICKS[0].get_button(12) and JOYSTICKS[0].get_button(17): # hotkey + start
                return
        result = scene.update(events, dt)
        if result:
            next_scene, state = result
            if next_scene:
                scene = scenes[next_scene]
                scene.start(state)
        scene.draw()
        pygame.display.flip()
        dt = clock.tick(60)

if __name__ == '__main__':
    main()
